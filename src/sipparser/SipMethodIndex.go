/*---------------- generated by abnf v0.1.0 2018-04-23 23:49:08.780 ----------------*/
package sipparser

/*---------------- index definition ----------------*/
const (
	SIP_METHOD_UNKNOWN   byte = 0
	SIP_METHOD_INVITE    byte = 1
	SIP_METHOD_PRACK     byte = 2
	SIP_METHOD_UPDATE    byte = 3
	SIP_METHOD_INFO      byte = 4
	SIP_METHOD_ACK       byte = 5
	SIP_METHOD_BYE       byte = 6
	SIP_METHOD_REGISTER  byte = 7
	SIP_METHOD_SUBSCRIBE byte = 8
	SIP_METHOD_NOTIFY    byte = 9
	SIP_METHOD_REFER     byte = 10
	SIP_METHOD_OPTIONS   byte = 11
	SIP_METHOD_MESSAGE   byte = 12
	SIP_METHOD_PUBLISH   byte = 13
)

func GetSipMethodIndex(src []byte, pos AbnfPos) (byte, AbnfPos) {
	len1 := AbnfPos(len(src))

	if pos >= len1 {
		return SIP_METHOD_UNKNOWN, pos
	}

	switch src[pos] {
	case 'A':
		pos++
		if (pos + 1) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'C') &&
			(src[pos+1] == 'K') {
			pos += 2
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_ACK, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'B':
		pos++
		if (pos + 1) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'Y') &&
			(src[pos+1] == 'E') {
			pos += 2
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_BYE, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'I':
		pos++
		if (pos < len1) && (src[pos] == 'N') {
			pos++
			switch src[pos] {
			case 'F':
				pos++
				if (pos < len1) && (src[pos] == 'O') {
					pos++
					if (pos >= len1) || !IsSipToken(src[pos]) {
						return SIP_METHOD_INFO, pos
					}
				}
				return SIP_METHOD_UNKNOWN, pos
			case 'V':
				pos++
				if (pos + 2) >= len1 {
					return SIP_METHOD_UNKNOWN, pos
				}
				if (src[pos] == 'I') &&
					(src[pos+1] == 'T') &&
					(src[pos+2] == 'E') {
					pos += 3
					if (pos >= len1) || !IsSipToken(src[pos]) {
						return SIP_METHOD_INVITE, pos
					}
				}
				return SIP_METHOD_UNKNOWN, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'M':
		pos++
		if (pos + 5) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'E') &&
			(src[pos+1] == 'S') &&
			(src[pos+2] == 'S') &&
			(src[pos+3] == 'A') &&
			(src[pos+4] == 'G') &&
			(src[pos+5] == 'E') {
			pos += 6
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_MESSAGE, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'N':
		pos++
		if (pos + 4) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'O') &&
			(src[pos+1] == 'T') &&
			(src[pos+2] == 'I') &&
			(src[pos+3] == 'F') &&
			(src[pos+4] == 'Y') {
			pos += 5
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_NOTIFY, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'O':
		pos++
		if (pos + 5) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'P') &&
			(src[pos+1] == 'T') &&
			(src[pos+2] == 'I') &&
			(src[pos+3] == 'O') &&
			(src[pos+4] == 'N') &&
			(src[pos+5] == 'S') {
			pos += 6
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_OPTIONS, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'P':
		pos++
		switch src[pos] {
		case 'R':
			pos++
			if (pos + 2) >= len1 {
				return SIP_METHOD_UNKNOWN, pos
			}
			if (src[pos] == 'A') &&
				(src[pos+1] == 'C') &&
				(src[pos+2] == 'K') {
				pos += 3
				if (pos >= len1) || !IsSipToken(src[pos]) {
					return SIP_METHOD_PRACK, pos
				}
			}
			return SIP_METHOD_UNKNOWN, pos
		case 'U':
			pos++
			if (pos + 4) >= len1 {
				return SIP_METHOD_UNKNOWN, pos
			}
			if (src[pos] == 'B') &&
				(src[pos+1] == 'L') &&
				(src[pos+2] == 'I') &&
				(src[pos+3] == 'S') &&
				(src[pos+4] == 'H') {
				pos += 5
				if (pos >= len1) || !IsSipToken(src[pos]) {
					return SIP_METHOD_PUBLISH, pos
				}
			}
			return SIP_METHOD_UNKNOWN, pos
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'R':
		pos++
		if (pos < len1) && (src[pos] == 'E') {
			pos++
			switch src[pos] {
			case 'F':
				pos++
				if (pos + 1) >= len1 {
					return SIP_METHOD_UNKNOWN, pos
				}
				if (src[pos] == 'E') &&
					(src[pos+1] == 'R') {
					pos += 2
					if (pos >= len1) || !IsSipToken(src[pos]) {
						return SIP_METHOD_REFER, pos
					}
				}
				return SIP_METHOD_UNKNOWN, pos
			case 'G':
				pos++
				if (pos + 4) >= len1 {
					return SIP_METHOD_UNKNOWN, pos
				}
				if (src[pos] == 'I') &&
					(src[pos+1] == 'S') &&
					(src[pos+2] == 'T') &&
					(src[pos+3] == 'E') &&
					(src[pos+4] == 'R') {
					pos += 5
					if (pos >= len1) || !IsSipToken(src[pos]) {
						return SIP_METHOD_REGISTER, pos
					}
				}
				return SIP_METHOD_UNKNOWN, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'S':
		pos++
		if (pos + 7) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'U') &&
			(src[pos+1] == 'B') &&
			(src[pos+2] == 'S') &&
			(src[pos+3] == 'C') &&
			(src[pos+4] == 'R') &&
			(src[pos+5] == 'I') &&
			(src[pos+6] == 'B') &&
			(src[pos+7] == 'E') {
			pos += 8
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_SUBSCRIBE, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	case 'U':
		pos++
		if (pos + 4) >= len1 {
			return SIP_METHOD_UNKNOWN, pos
		}
		if (src[pos] == 'P') &&
			(src[pos+1] == 'D') &&
			(src[pos+2] == 'A') &&
			(src[pos+3] == 'T') &&
			(src[pos+4] == 'E') {
			pos += 5
			if (pos >= len1) || !IsSipToken(src[pos]) {
				return SIP_METHOD_UPDATE, pos
			}
		}
		return SIP_METHOD_UNKNOWN, pos
	}

	return SIP_METHOD_UNKNOWN, pos
}
